/*
  游戏服务器开发中使用的生成分布式唯一ID的方式
*/
/*
 ID 的组成结构 使用64位：
 `|<symbol(1)->|<-server(14)->|<-index(4)->|<-Increment(16)->|<-time(29)->|`
 symbol(1)：1位 符号位 保留
 serverid(14)：14位保存生成id的所在区服id，最大值是16384，完全可以满足服务器数量要求：举个例子：按照1天开5服，游戏生命周期5年的话 开服时365*5*5=9125，所以足可以满足当前开服的需求
 index(4)： 4位索引，每个区服中运行N个进程同时进行id生成不重复，最大是15，允许一组服中同时15个进程同时生成ID操作。
 Increment(16)：16位存自增数字，使用 unsigned int，最大值是65536，超过65536后从1再次开始累加，理论上每秒生成ID数量小于65536个不会出现重复（在高并发情况下，可以逻辑判断下，如果1秒内这个数字从0到达65535后，可以等待1秒过去后再次生成）
 time(29)：29位，保存当前时间戳，当前获取时间转换成二进制占用31字节，此处使用29字节存储，舍弃前面两位，后面29位一轮下来需要17年，在游戏的生命周期内是可以采用这种方式的。
 
 
 代码中涉及的代码讲解：
 
  简单例子： 获取 10 的 二进制 左边2个字节
   10的二进制是 1010
   那么选择一个数字进行右移两位后还要大于等于两位；
   
   选择 1 << 2 操作的话 100  ~100 = 011(前面N个1) ；11111011&1010 == 1010 达不到效果
   选择 3 << 2  操作的话 1100 ~1100 = 0011  ；11111110011&1010 = 10  成功获取后字节
   
   结论:获取数字M 二进制右边N个字节，那么选择一个数K转换成二进制位数 要大于等于M二进制位数减去N 并且K 满足（2的n次方-1），二进制全为1；
   
    ~(7 << COUNTER_MOVE)：上面说获取当前时间转换成2进制占用31位字节，程序中使用29位存储，那么需要去掉前面的两位，在二进制&操作中 如果前两位是00后面全是1，
 这样&出来最大的数字也就是29个字节，7 的二进制是111 右移29位编程了 111 00000000000000000000000000000，这样取反操作变成了 000 11111111111111111111111111111
 与time进行&操作获取了后面的29位；
  此处为什么选择7进行移位操作呢？7的二进制是三个1，右移29之后取反 能够保证对 31字节的time前面全部去掉

*/
//测试代码


/*
    serverid 和 index 需要传参操作
*/

#define sint64 long long

#define uint16 unsigned int

static uint16 g_IncrementId = 0;

int main() {

    printf("我在编程中国学C语言\n\n");
    
    sint64 serverid = 1; //服务器 11区服
    
    sint64 serverindex = 1;//服务器中生成ID的第一个进程
    
    sint64 m_Guid = 0;
    
    m_Guid += serverid << 49;

    m_Guid += serverindex << 45;
    
    int tmp=g_IncrementId++;
    
    m_Guid +=  tmp << 29;
    
    int nTime = (int)time(NULL);
    
    nTime &= ~(7 << COUNTER_MOVE); 
    
    m_Guid += nTime;
    
    printf("%lld \n",m_Guid);


    return 0;

}
//下班了。。。有时间在补充
/*
  根据guid获取创建时间
*/

/*
  根据guid获取所在server
*/

